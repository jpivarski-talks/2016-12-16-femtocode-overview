\documentclass{beamer}

%
% Choose how your presentation looks.
%
% For more themes, color themes and font themes, see:
% http://deic.uab.es/~iblanes/beamer_gallery/index_by_theme.html
%
\mode<presentation>
{
  \usetheme{default}      % or try Darmstadt, Madrid, Warsaw, ...
  \usecolortheme{default} % or try albatross, beaver, crane, ...
  \usefonttheme{default}  % or try serif, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[page number]
  \setbeamercolor{frametitle}{fg=white}
  \setbeamercolor{footline}{fg=black}
} 

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{tikz}
\usepackage{listings}
\usepackage{courier}
\usepackage{minted}

\xdefinecolor{darkblue}{rgb}{0.1,0.1,0.7}
\xdefinecolor{darkorange}{rgb}{0.8,0.5,0}
\xdefinecolor{darkred}{rgb}{0.7,0,0}
\xdefinecolor{dianablue}{rgb}{0.18,0.24,0.31}
\definecolor{commentgreen}{rgb}{0,0.6,0}
\definecolor{stringmauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},      % choose the background color
  basicstyle=\ttfamily\small,         % size of fonts used for the code
  breaklines=true,                    % automatic line breaking only at whitespace
  captionpos=b,                       % sets the caption-position to bottom
  commentstyle=\color{commentgreen},  % comment style
  escapeinside={\%*}{*)},             % if you want to add LaTeX within your code
  keywordstyle=\color{blue},          % keyword style
  stringstyle=\color{stringmauve},    % string literal style
  showstringspaces=false,
  showlines=true
}

\lstdefinelanguage{scala}{
  morekeywords={abstract,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield},
  otherkeywords={=>,<-,<\%,<:,>:,\#,@},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}

\title[2016-12-16-femtocode-overview]{Femtocode Overview}
\author{Jim Pivarski}
\institute{Princeton University -- DIANA}
\date{December 16, 2016}

\begin{document}

\logo{\pgfputat{\pgfxy(0.11, 8)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}}}\pgfputat{\pgfxy(0.11, -0.6)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\includegraphics[height=0.99 cm]{diana-hep-logo.png}\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (4.9 cm, 1 cm);}}}}

\begin{frame}
  \titlepage
\end{frame}

\logo{\pgfputat{\pgfxy(0.11, 8)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\includegraphics[height=1 cm]{diana-hep-logo.png}}}}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}

\begin{frame}{Essential and accidental complexity}
\vspace{0.25 cm}
\textcolor{darkorange}{\bf End-user physics analysis \underline{must} include the following:}
\begin{description}
\item[\bf big data pull:] probably with on-the-fly filters and transformations, given the scale of the data,
\item[\bf manipulations:] at least plotting, but probably fitting, unfolding, cross-comparisons, machine learning, etc.
\end{description}

\vfill
\begin{uncoverenv}<2->
\textcolor{darkorange}{\bf Currently, most analyses also include:}
\begin{description}
\item[\bf private skim:] intermediate-sized dataset with more fields than necessary.
\begin{itemize}
\item Since the big data pull takes so long, fields that {\it might} be needed are included as a hedge.
\item This makes the big data pull bigger.

\textcolor{gray}{(The more skim you have, the more you need!)}
\end{itemize}
\end{description}
\end{uncoverenv}
\end{frame}

\begin{frame}{Reducing dataset size early}
\begin{center}
\only<1>{\includegraphics[width=0.8\linewidth]{pseudoplot.pdf}}
\only<2>{\includegraphics[width=0.8\linewidth]{pseudoplot2.pdf}}
\end{center}

Ideally, data should go directly from the collaboration-wide store (e.g.\ MiniAOD) into plots, fits, or machine learning algorithms, rapidly enough that there's no temptation to overstock the big data pull.
\end{frame}

\begin{frame}{Industry {\it expects} interactive analysis}

Business intelligence has traditionally been interactive; there's a race to provide interactivity with Big Data backends:

\begin{center}
\textcolor{blue}{Ibis, Impala, Kudu, Drill, \ldots}
\end{center}

all aim to yield sub-second results from terabytes or petabytes of data.

\vfill
\textcolor{darkorange}{\bf Shouldn't we?}
\end{frame}

\begin{frame}{How could this even be possible?}
\vspace{0.5 cm}
\textcolor{darkorange}{\bf How could a week-long GRID job be reduced to seconds?}

\vspace{0.5 cm}
\begin{columns}[t]
\column{0.5\linewidth}
\textcolor{darkblue}{\underline{\bf GRID job}}

\begin{itemize}
\item Includes data fields that {\it might} be useful.

\item Framework reconstructs whole C++ objects, regardless of whether they're split in ROOT: loading {\it dozens} of unused fields.

\item Bad choices in user's C++.

\item Finding storage for and moving the big output files.
\end{itemize}

\column{0.5\linewidth}
\textcolor{darkblue}{\underline{\bf Interactive query}}

\begin{itemize}
\item Limited to fields mentioned in the query.

\item Only loads the attributes mentioned in the query: rarely more than 5--10.

\item Can employ JIT or other optimizations.

\item Can cache frequently requested fields or subexpressions among users.
\end{itemize}
\end{columns}

\vspace{0.5 cm}
\textcolor{gray}{(Not to mention {\it user's time} needed to write and test the code.)}
\end{frame}

\begin{frame}{}
\begin{center}
\textcolor{darkblue}{\huge But\ldots}
\end{center}
\end{frame}

\begin{frame}[fragile]{Physics data are different}
\vspace{0.5 cm}
Most datasets in industry are (the equivalent of) flat ntuples:
\begin{itemize}
\item SQL tables
\item OLAP hypercubes
\item exceptions are often handled with user-defined functions
(e.g.\ lat, lon $\to$ zip code, followed by ntuple analysis on zip codes).
\end{itemize}

\vfill
\begin{uncoverenv}<2->
Modern SQL engines are capable of nested structure, but have no functions for dealing with the structure other than exploding it.

\vspace{0.25 cm}
\textcolor{darkblue}{Physics equivalent:} doing all analysis with TTreeFormula:

\begin{lstlisting}[language=c]
ntuple->Draw("tracks[].hits[].residual >> hresid");
\end{lstlisting}
\end{uncoverenv}
\end{frame}

\begin{frame}{Physics data are different}
\vspace{0.25 cm}
{\bf Spark has two options:}
\begin{enumerate}
\item SQL-style analysis with DataFrames \textcolor{gray}{(Column expressions)},
\item General analysis with RDDs \textcolor{gray}{(any Scala or Python function)}.
\end{enumerate}
When I asked Michael Armbridge (Databricks) about this, he said the goal of DataFrames was to cover ``95\% of the use-cases.''

\vfill
Physics analysis with flat ntuples is within their ``95\%,'' but something like this isn't:
\begin{center}
\begin{minipage}{0.95\linewidth}
\textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
\end{minipage}
\end{center}

\vfill
Restricting to flat ntuple analysis would require more skims. Spark solves the bookkeeping aspects, but not the fundamental problem.
\end{frame}

\begin{frame}{We need expressiveness {\it and} optimizability}
\vspace{0.5 cm}
\begin{center}
\begin{minipage}{0.9\linewidth}
To replace GRID jobs with declarative queries, the query \mbox{language} must be
\begin{itemize}
\item \textcolor{darkblue}{\it more expressive} than SQL and TTreeFormula,
\item \textcolor{darkblue}{\it less expressive} than code (to permit optimizations and subexpression caching, like Spark's DataFrames).
\end{itemize}

\vspace{0.5 cm}
Nothing exists to fill this gap. \textcolor{gray}{(I've been searching for most of this year.)}

\vspace{0.5 cm}
Need to invent a query language: \textcolor{darkblue}{Femtocode}.
\end{minipage}
\end{center}
\end{frame}

%% \begin{frame}[fragile]{Nested query in SQL}
%% \vspace{0.25 cm}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{minted}{sql}
%% WITH hit_stats AS (
%%   SELECT hit.track_id, COUNT(*) AS hit_count FROM hit
%%     GROUP BY hit.track_id),
%%  track_sorted AS (
%%     SELECT track.*, 
%%     ROW_NUMBER() OVER (
%%      PARTITION BY track.event_id
%%      ORDER BY hit_stats.hit_count DESC)
%%   track_ordinal FROM track INNER JOIN hit_stats
%%     ON hit_stats.track_id = track.id
%%     WHERE ABS(track.eta) < 2.4)
%%  SELECT * FROM event INNER JOIN track_sorted
%%    ON track_sorted.event_id = event.id
%% WHERE
%%   track_sorted.track_ordinal = 1
%% \end{minted}
%% \end{frame}

%% \begin{frame}[fragile]{Nested query in C++}
%% \vspace{0.25 cm}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{minted}{c++}
%% Track *best = NULL;
%% for (int i = 0;  i < tracks.size();  i++) {
%%   if (fabs(tracks[i]->eta) < 2.4)
%%     if (best == NULL ||
%%         tracks[i]->hits.size() < best->hits.size())
%%       best = tracks[i];
%% }
%% if (best != NULL)
%%   return best->pt;
%% else
%%   return 0.0;
%% \end{minted}
%% \end{frame}

%% \begin{frame}[fragile]{Nested query in Femtocode}
%% \vspace{0.25 cm}
%% \begin{center}
%% \begin{minipage}{0.95\linewidth}
%% \textcolor{darkblue}{``Momentum of the track with $|\eta|$ $<$ 2.4 that has the most hits.''}
%% \end{minipage}
%% \end{center}
%% \small
%% \begin{onlyenv}<1>
%% \begin{minted}{scala}
%% event.tracks
%%      .filter(t => abs(t.eta) < 2.4)
%%      .maxBy(t => t.hits.size)
%%      .map(t => t.pt)
%%      .impute(0.0)
%% \end{minted}
%% \end{onlyenv}
%% \begin{onlyenv}<2>
%% \begin{minted}{bash}
%% event.tracks
%%      .filter(abs($1.eta) < 2.4)
%%      .maxBy($1.hits.size)
%%      .map($1.pt)
%%      .impute(0.0)
%% \end{minted}
%% \end{onlyenv}
%% \end{frame}

\begin{frame}{Features of Femtocode}
\vspace{0.5 cm}
\begin{description}
\item[Declarative:]<1-> order written/order evaluated need not be the same.
\item[Functional:]<2-> map/filter/maxBy instead of explicit for loops.
\item[Vectorizable:]<3-> code appears to act on rows (e.g.\ events), but automatically translated to operate on columns.
\item[No unbounded loops:]<4-> processing time strictly scales with input data size; not Turing complete.
\item[No runtime errors:]<5-> any submitted query will return some result.
\item[Statically typed:]<6-> stronger type system than most languages is needed to eliminate runtime errors.
\item[Full type inference:]<7-> explicitly writing down types is annoying.
\item[No recursion:]<8-> combining recursion with \textcolor{darkblue}{no unbounded loops} is complicated, but big data pulls don't need recursion.
\item[Pythonic syntax:]<9-> familiar to physics users; don't invent new syntax unless absolutely necessary.
\end{description}
\end{frame}

%% \begin{frame}[fragile]{High-level overview}
%% \vspace{0.5 cm}
%% Femtocode transforms datasets into
%% \begin{itemize}
%% \item other datasets \textcolor{gray}{(can be virtual/intermediate, not stored)},
%% \item flat tables of numbers \textcolor{gray}{(for unbinned fits/machine learning)},
%% \item Histogrammar aggregations \textcolor{gray}{(broad class of aggregations)}.
%% \end{itemize}

%% It is used only for the \textcolor{darkblue}{\bf big data pull}, not the \textcolor{darkblue}{\bf manipulations}.

%% \vspace{0.5 cm}
%% \begin{uncoverenv}<2->
%% \textcolor{darkorange}{\bf \underline{Example use:}}

%% \small
%% \begin{minted}{python}
%% h = db.dataset("ttbar-MC")
%%   .withColumn(varName = "<Femtocode goes here>")
%%   .filter("<Femtocode using varName>")
%%   .flatMap("<Femtocode changing nesting level>")
%%   .Label(hist1 = Bin(100, -5.0, 5.0, "<Femtocode>"),
%%          hist2 = Bin(20, 0.0, 100.0, "<Femtocode>"),
%%          hist3 = Bin(314, -pi, pi, "<Femtocode>"))
%% \end{minted}

%% \normalsize
%% followed by Python analysis with {\small\tt h[\textcolor{darkred}{"hist1"}]}, {\small\tt h[\textcolor{darkred}{"hist2"}]}\ldots
%% \end{uncoverenv}
%% \end{frame}

\begin{frame}{What is a dataset?}
\vspace{0.25 cm}
\begin{center}
\begin{minipage}{0.9\linewidth}
\textcolor{darkorange}{\bf Collection of unordered, identically typed values.}

\vspace{0.25 cm}
Typically the top of the type tree is a ``record,'' which has named, typed fields.
\end{minipage}
\end{center}

\begin{uncoverenv}<2->
Many concrete realizations:
\begin{itemize}
\item \textcolor{darkblue}{Terascope server:} responds to user queries with aggressive optimizations. Goal is sub-second response.
\item \textcolor{darkblue}{ROOT files:} integrates with ROOT team's efforts at functional chains; Femtocode may become the ROOT 7 TTreeFormula.
\item \textcolor{darkblue}{GPU:} Femtocode's vectorizability fits perfectly into the GPU's SIMD architecture; special optimization for \textcolor{darkblue}{Terascope server}.
\item \textcolor{darkblue}{Spark:} extend the usability of Spark's DataFrames.
\item \textcolor{darkblue}{Apache Arrow:} target many big data platforms at once.
\end{itemize}
\end{uncoverenv}
\end{frame}

\begin{frame}{Abstract type system}
\vspace{0.5 cm}
Space of possible datasets is defined by the type system.

\begin{description}
\item[null:] type with only one value
\item[boolean:] not the same as integers
\item[number:] further defined by attributes: \textcolor{darkblue}{min}, \textcolor{darkblue}{max}, \textcolor{darkblue}{whole}

{\tt whole == True} means integer,

{\tt whole == False} means floating point

\item[string:] \textcolor{darkblue}{charset} (``bytes'' or ``unicode''), \textcolor{darkblue}{fewest}, \textcolor{darkblue}{most};

\textcolor{darkblue}{fewest/most} are constraints on the string length

\item[collection:] \textcolor{darkblue}{fewest}, \textcolor{darkblue}{most}, \textcolor{darkblue}{ordered}

fixed-size arrays/matrices have {\tt fewest == most and ordered == True}

\item[record:] defined by a dictionary of \textcolor{darkblue}{fields}
\item[union:] tagged union, such as {\tt union(null, string)} for a nullable string type.
\end{description}
\end{frame}

\begin{frame}[fragile]{This is a high-granularity type system}
\vspace{0.5 cm}
The ``number'' type has \textcolor{darkblue}{min} and \textcolor{darkblue}{max} attributes, and these can be open or closed intervals.
\begin{itemize}
\item {\tt real(almost(0), 10)} means $\{x | x \in \mathbb{R}\mbox{ and } 0 < x \le 10\}$
\item {\tt integer(almost(-inf), almost(inf))} means $\mathbb{Z}$
\item {\tt extended(-inf, inf)} means $\mathbb{R} \cup \{-\infty, \infty\}$
\item {\tt union(integer, real(0))} means

\hfill $\mathbb{Z} \cup \{x | x \in \mathbb{R}\mbox{ and } x \ge 0\}$
\end{itemize}

\vfill
\begin{uncoverenv}<2->
\textcolor{darkorange}{\bf Why?}

The type system has to know enough to eliminate the possibility of runtime error.

\vspace{0.2 cm}
\textcolor{darkorange}{\bf Example}

If {\tt x} and {\tt y} are {\tt real}, then ``{\tt x/y}'' is a type error but

\vspace{0.2 cm}
\mbox{ } \hfill ``{\tt if (y != 0.0) \{x/y\} else \{null\}}'' \hfill \mbox{ }

\vspace{0.2 cm}
is legal. The error message directs the user to fix their code.
\end{uncoverenv}
\end{frame}







\end{document}
